<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>KoHat Live Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      height: 100%;
      width: 100%;
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }
    #live {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 4px 8px;
      background: red;
      color: white;
      font-size: 14px;
      border-radius: 4px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div style="position:relative;width:100%;height:100%;">
    <video id="remote" autoplay playsinline></video>
    <span id="live">Connecting…</span>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import * as mediasoupClient from 'https://esm.sh/mediasoup-client@3';

    const el = (id) => document.getElementById(id);

    function getChannelId() {
      const ch = new URLSearchParams(location.search).get('ch');
      if (!['b1','b2'].includes(ch)) return null;
      return ch;
    }
    const channelId = getChannelId();
    if (channelId) document.title = channelId === 'b1' ? 'Broadcaster 1' : 'Broadcaster 2';

    const socket = io();
    let device, recvTransport;
    const mediaStream = new MediaStream();
    let videoConsumer = null, audioConsumer = null;

    function attachTrack(kind, track){
      if (kind === 'video') {
        const old = mediaStream.getVideoTracks()[0];
        if (old) mediaStream.removeTrack(old);
        mediaStream.addTrack(track);
      } else {
        const old = mediaStream.getAudioTracks()[0];
        if (old) mediaStream.removeTrack(old);
        mediaStream.addTrack(track);
      }
      if (!el('remote').srcObject) el('remote').srcObject = mediaStream;
    }

    async function loadDevice(){
      const caps = await new Promise(res => socket.emit('getRtpCapabilities', res));
      device = new mediasoupClient.Device();
      await device.load({ routerRtpCapabilities: caps });
    }

    async function makeRecvTransport() {
      const params = await new Promise(res => socket.emit('createRecvTransport', { channelId }, res));
      if (params?.error) throw new Error(params.error);
      const t = device.createRecvTransport(params);
      t.on('connect', ({ dtlsParameters }, callback, errback) => {
        socket.emit('connectRecvTransport', { channelId, dtlsParameters }, (r) => {
          r === 'ok' ? callback() : errback(new Error('connect failed'));
        });
      });
      return t;
    }

    async function consumeKind(kind) {
      const data = await new Promise(res => socket.emit('consume', { channelId, rtpCapabilities: device.rtpCapabilities, kind }, res));
      if (data?.error) {
        if (kind === 'video') el('live').textContent = 'Waiting for broadcaster…';
        return null;
      }
      const consumer = await recvTransport.consume(data);
      attachTrack(kind, consumer.track);
      await new Promise(res => socket.emit('resume', { consumerId: consumer.id }, res));
      return consumer;
    }

    async function watch() {
      if (!channelId) {
        el('live').textContent = 'No channel selected';
        return;
      }
      try {
        el('live').textContent = 'Connecting…';
        await new Promise(res => socket.emit('join', { channelId }, res));
        await loadDevice();
        recvTransport = await makeRecvTransport();
        videoConsumer = await consumeKind('video');
        audioConsumer = await consumeKind('audio');
        if (videoConsumer) {
          el('live').textContent = 'LIVE';
        } else {
          el('live').textContent = 'Waiting for broadcaster…';
        }
      } catch (e) {
        console.error(e);
        el('live').textContent = 'Error: ' + (e.message || 'unknown');
      }
    }

    // reconsume on new producer
    socket.on('newProducer', async ({ channelId: cid, kind }) => {
      if (cid !== channelId || !device || !recvTransport) return;
      try {
        const data = await new Promise(res => socket.emit('consume', { channelId, rtpCapabilities: device.rtpCapabilities, kind }, res));
        if (!data?.error) {
          const newConsumer = await recvTransport.consume(data);
          attachTrack(kind, newConsumer.track);
          await new Promise(res => socket.emit('resume', { consumerId: newConsumer.id }, res));
          if (kind === 'video') videoConsumer = newConsumer;
          else audioConsumer = newConsumer;
        }
      } catch (e) { console.error(e); }
    });

    watch();
  </script>
</body>
</html>