<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Broadcast â€¢ KoHat Live</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="/lives.html" class="brand">ðŸŽ¥ KoHat Live</a>
    <div class="actions">
      <button id="endBtn" class="btn ghost">End Stream</button>
      <button id="signout" class="btn">Sign out</button>
    </div>
  </header>

  <!-- Auth guard -->
  <script>
    (function requireAuth(){
      const token = localStorage.getItem('token') || localStorage.getItem('authToken');
      if (!token) location.replace('/signin.html');
    })();
  </script>

  <!-- Main -->
  <main class="main">
    <section class="card" style="max-width:960px;margin:0 auto">
      <h2 style="margin-top:0">Broadcast Console</h2>

      <div class="badges">
        <span id="liveBadge" class="badge">OFFLINE</span>
        <span id="uptime" class="badge">00:00:00</span>
        <span id="viewers" class="badge">ðŸ‘€ 0</span>
      </div>

      <div id="skel" class="skel" style="margin:12px 0; display:none;"></div>
      <video id="preview" class="video" autoplay muted playsinline style="display:block"></video>

      <div class="toolbar" style="margin-top:12px;flex-wrap:wrap">
        <button id="btnStart" class="btn">Go Live (Camera)</button>
        <button id="btnScreen" class="btn">Share Screen</button>
        <button id="btnCam" class="btn ghost">Disable Cam</button>
        <button id="btnMic" class="btn ghost">Mute Mic</button>
        <button id="btnFlip" class="btn">Flip Camera</button>
        <button id="btnEnd" class="btn ghost danger">End Live</button>
        <select id="cameraSelect" class="btn" style="display:none; max-width:260px;"></select>
        <span class="right small" id="status">Idle</span>
      </div>

      <p class="small" style="margin-top:10px;opacity:.8;text-align:center">
        Logged in as <span id="who"></span>
      </p>
    </section>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <small>Â© 2025 KoHat Live</small>
    <nav>
      <a href="#">Terms</a>
      <a href="#">Privacy</a>
      <a href="#">Contact</a>
    </nav>
  </footer>

  <div id="toast" class="toast"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import * as mediasoupClient from 'https://esm.sh/mediasoup-client@3';

    // --------- Small helpers ---------
    const $ = (id) => document.getElementById(id);
    const toast = (t) => { const x = $('toast'); if (!x) return; x.textContent = t; x.style.display='block'; setTimeout(()=>x.style.display='none', 1600); };
    const setBadge = (on) => { const b = $('liveBadge'); b.textContent = on ? 'LIVE' : 'OFFLINE'; b.className = 'badge ' + (on ? 'live' : ''); };
    const skel = (show) => { $('skel').style.display = show ? 'block' : 'none'; $('preview').style.display = show ? 'none' : 'block'; };

    // --------- Auth + live params ---------
    const token = localStorage.getItem('token') || localStorage.getItem('authToken') || '';
    const user = JSON.parse(localStorage.getItem('user') || '{}');
    $('who').textContent = user.email || '';
    $('signout').onclick = () => { localStorage.clear(); location.replace('/signin.html'); };

    const qp = new URLSearchParams(location.search);
    const liveId = qp.get('id') || null;
    const slug = qp.get('slug') || null;
    if (!liveId && !slug) {
      alert('Missing live id/slug. Create a live from the Live List first.');
      location.replace('/lives.html');
    }

    // --------- Socket.IO (auth handshake) ---------
    const socket = io({
      auth: { role: 'broadcaster', token, liveId, slug }
    });
    socket.on('connect', () => toast('Connected'));
    socket.io.on('reconnect_attempt', () => toast('Reconnectingâ€¦'));
    socket.on('disconnect', () => toast('Disconnected'));
    socket.on('viewers', (n) => { $('viewers').textContent = `ðŸ‘€ ${n}`; });

    // --------- Mediasoup state ---------
    let device, sendTransport, currentStream = null, videoProducer = null, audioProducer = null;
    let startedAt = 0, upTimer = null;

    function startUptime(){
      startedAt = Date.now();
      if (upTimer) clearInterval(upTimer);
      upTimer = setInterval(()=>{
        const s = Math.floor((Date.now()-startedAt)/1000);
        const h = String(Math.floor(s/3600)).padStart(2,'0');
        const m = String(Math.floor((s%3600)/60)).padStart(2,'0');
        const sec = String(s%60).padStart(2,'0');
        $('uptime').textContent = `${h}:${m}:${sec}`;
      }, 1000);
    }
    function stopStream(stream){
      if (!stream) return;
      for (const t of stream.getTracks()) { try{ t.stop(); }catch{} }
    }

    async function loadDevice(){
      if (device) return;
      const caps = await new Promise(res => socket.emit('getRtpCapabilities', null, res));
      device = new mediasoupClient.Device();
      await device.load({ routerRtpCapabilities: caps });
    }
    async function ensureSendTransport(){
      if (sendTransport) return;
      const params = await new Promise(res => socket.emit('createSendTransport', null, res));
      if (params?.error) throw new Error(params.error);
      sendTransport = device.createSendTransport(params);
      sendTransport.on('connect', ({ dtlsParameters }, callback, errback) =>
        socket.emit('connectSendTransport', { dtlsParameters }, (r)=> r==='ok'?callback():errback(new Error('connect failed'))));
      sendTransport.on('produce', ({ kind, rtpParameters }, callback, errback) =>
        socket.emit('produce', { kind, rtpParameters }, (data)=> data?.error ? errback(new Error(data.error)) : callback({ id: data.id })));
    }

    function pickEncodings() {
      return [
        { rid: 'q', maxBitrate: 150_000, scaleResolutionDownBy: 4 }, // ~360p
        { rid: 'h', maxBitrate: 600_000, scaleResolutionDownBy: 2 }, // ~540â€“720p
        { rid: 'f', maxBitrate: 1_500_000, scaleResolutionDownBy: 1 } // ~720â€“1080p
      ];
    }

    async function produceOrReplace(kind, track) {
      if (kind === 'video') {
        if (videoProducer) { await videoProducer.replaceTrack({ track }); return; }
        const h264 = device.rtpCapabilities.codecs.find(c => /video\/H264/i.test(c.mimeType));
        const opts = { track, encodings: pickEncodings() };
        if (h264) opts.codec = h264;
        videoProducer = await sendTransport.produce(opts);
      } else if (kind === 'audio') {
        if (!track) return;
        if (audioProducer) await audioProducer.replaceTrack({ track });
        else audioProducer = await sendTransport.produce({ track });
      }
    }

    // --------- Camera enumeration for dropdown/flip ---------
    const cameraSelect = $('cameraSelect');
    async function populateCameras() {
      if (!cameraSelect) return;
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === 'videoinput');
        cameraSelect.innerHTML = '';
        cams.forEach((d, i) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `Camera ${i+1}`;
          cameraSelect.appendChild(opt);
        });
        cameraSelect.style.display = cams.length > 1 ? 'inline-block' : 'none';
      } catch { cameraSelect.style.display = 'none'; }
    }

    // --------- Swap local preview and publish ---------
    async function swapToStream(stream, label){
      $('preview').srcObject = stream;

      await loadDevice();
      await ensureSendTransport();

      const v = stream.getVideoTracks()[0] || null;
      const a = stream.getAudioTracks()[0] || null;
      if (v) await produceOrReplace('video', v);
      if (a) await produceOrReplace('audio', a);

      if (currentStream && currentStream !== stream) stopStream(currentStream);
      currentStream = stream;

      setBadge(true);
      if (!startedAt) startUptime();

      skel(false);
      $('status').textContent = (label === 'screen') ? 'ðŸ–¥ï¸ Live (Screen)' : 'ðŸ“· Live (Camera)';

      try {
        if (label !== 'screen') await populateCameras(); else cameraSelect.style.display = 'none';
      } catch {}
      toast(label === 'screen' ? 'Screen sharing started' : 'Camera live');
    }

    async function startCamera(){
      $('status').textContent = 'Requesting camera/micâ€¦';
      skel(true);
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
        await swapToStream(stream, 'camera');
      } catch (e) {
        $('status').textContent = 'Failed: ' + (e?.message || e) + ' (HTTPS needed)';
        skel(false);
        throw e;
      }
    }

    async function startScreen(){
      $('status').textContent = 'Requesting screenâ€¦';
      skel(true);
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        const t = stream.getVideoTracks()[0];
        if (t) t.onended = async () => { toast('Screen share ended'); try { await startCamera(); } catch {} };
        await swapToStream(stream, 'screen');
      } catch (e) {
        $('status').textContent = 'Failed: ' + (e?.message || e);
        skel(false);
        throw e;
      }
    }

    // --------- Buttons ---------
    $('btnStart').onclick  = () => startCamera().catch(console.error);
    $('btnScreen').onclick = () => startScreen().catch(console.error);

    $('btnCam').onclick = () => {
      const track = currentStream?.getVideoTracks()[0];
      if (!track) return;
      track.enabled = !track.enabled;
      $('btnCam').textContent = track.enabled ? 'Disable Cam' : 'Enable Cam';
      toast(track.enabled ? 'Camera enabled' : 'Camera disabled');
    };
    $('btnMic').onclick = () => {
      const track = currentStream?.getAudioTracks()[0];
      if (!track) return;
      track.enabled = !track.enabled;
      $('btnMic').textContent = track.enabled ? 'Mute Mic' : 'Unmute Mic';
      toast(track.enabled ? 'Mic unmuted' : 'Mic muted');
    };

    $('btnFlip').onclick = async () => {
      try {
        // Try to flip by facingMode
        const current = currentStream?.getVideoTracks()[0];
        const facing = (current?.getSettings?.().facingMode === 'user') ? 'environment' : 'user';
        const newStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact: facing } }, audio: true });
        await swapToStream(newStream, 'camera');
        $('status').textContent = `Camera flipped (${facing})`;
      } catch (err) { console.error(err); toast('Could not flip camera on this device'); }
    };

    $('btnEnd').onclick = async () => {
      if (!liveId) { location.replace('/lives.html'); return; }
      if (confirm('End this live?')) {
        try {
          const r = await fetch(`/api/lives/${encodeURIComponent(liveId)}/end`, {
            method: 'PATCH',
            headers: { 'Authorization': token }
          });
          // Clean producers/tracks locally
          try { videoProducer?.close(); } catch {}
          try { audioProducer?.close(); } catch {}
          stopStream(currentStream); currentStream = null; setBadge(false);
          if (!r.ok) { const j = await r.json().catch(()=>({})); throw new Error(j?.error || 'End live failed'); }
          location.replace('/lives.html');
        } catch (e) {
          alert(e.message || 'Failed to end live');
        }
      }
    };

    // Also wire header "End Stream" to same action
    $('endBtn').onclick = () => $('btnEnd').click();

    // Optional: auto-start camera when page opens
    // startCamera().catch(()=>{});
  </script>
</body>
</html>