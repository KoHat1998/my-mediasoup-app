<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>KoHat Live Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; width:100%; overflow:hidden; }
    video { width:100%; height:100%; object-fit:contain; background:#000; }
    #status {
      position:absolute; top:10px; left:10px; z-index:10;
      padding:4px 8px; border-radius:4px; color:#fff; font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:rgba(0,0,0,.7);
    }
  </style>
</head>
<body>
  <div style="position:relative;width:100%;height:100%;">
    <video id="remoteVideo" autoplay playsinline></video>
    <span id="status">Player ready. Waiting for init…</span>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import * as mediasoupClient from 'https://esm.sh/mediasoup-client@3';

    const statusEl = document.getElementById('status');
    const videoEl  = document.getElementById('remoteVideo');

    // -------- helpers ----------
    function setStatus(msg, type='info') {
      statusEl.textContent = msg;
      statusEl.style.backgroundColor =
        type === 'live'  ? '#b00020' :
        type === 'error' ? '#6a1b1a' : 'rgba(0,0,0,.7)';
      if (window.flutter_inappwebview?.callHandler) {
        window.flutter_inappwebview.callHandler('playerStatus', { message: msg, type });
      }
      console.log('[PLAYER]', msg);
    }
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

    // -------- mediasoup state ----------
    let socket;
    let device;
    let recvTransport;
    let videoConsumer, audioConsumer;
    const mediaStream = new MediaStream();
    videoEl.srcObject = mediaStream;

    function attachTrack(kind, track){
      const old = kind==='video' ? mediaStream.getVideoTracks()[0] : mediaStream.getAudioTracks()[0];
      if (old) mediaStream.removeTrack(old);
      if (track) mediaStream.addTrack(track);
    }

    async function loadDevice() {
      const caps = await emitAck('getRtpCapabilities', null);
      device = new mediasoupClient.Device();
      await device.load({ routerRtpCapabilities: caps });
    }

    async function createRecvTransport() {
      const params = await emitAck('createRecvTransport', null);
      if (params?.error) throw new Error(params.error);
      const t = device.createRecvTransport(params);
      t.on('connect', ({ dtlsParameters }, cb, eb) => {
        emitAck('connectRecvTransport', { dtlsParameters }).then(cb).catch(eb);
      });
      return t;
    }

    async function consumeKind(kind) {
      const data = await emitAck('consume', { rtpCapabilities: device.rtpCapabilities, kind });
      if (data?.error) {
        console.log(`No ${kind} yet:`, data.error);
        return null;
      }
      const c = await recvTransport.consume(data);
      if (kind === 'video') attachTrack('video', c.track);
      else attachTrack('audio', c.track);
      await emitAck('resume', { consumerId: c.id });
      return c;
    }

    // -------- socket emit with ack ----------
    function emitAck(event, payload){
      return new Promise((resolve, reject) => {
        socket.timeout(10000).emit(event, payload, (res) => {
          if (res && res.error) return reject(new Error(res.error));
          resolve(res);
        });
      });
    }

    // -------- public bridge (Flutter can still call these) ----------
    window.playerBridge = {
      /**
       * options: { host, token?, role='viewer', channelId?, slug?, liveId? }
       * We send {role, token, slug, liveId} in the Socket.IO handshake.
       */
      async init(options) {
        try {
          const host = options?.host || location.origin;
          const channel = options?.channelId || options?.slug || options?.liveId || options?.id || options?.room || options?.ch;
          if (!channel) throw new Error('channelId/slug/liveId required');

          const rawToken = options?.token
            || new URL(location.href).searchParams.get('token')
            || '';

          const slug   = channel;
          const liveId = channel;

          setStatus('Connecting…');
          socket = io(host, {
            transports: ['websocket','polling'],
            auth: {
              role: options?.role || 'viewer',
              token: rawToken, // raw "eyJ…" or "Bearer eyJ…"; server normalizes
              slug,
              liveId
            }
          });

          await new Promise((resolve, reject) => {
            if (socket.connected) return resolve();
            const ok = () => { cleanup(); resolve(); };
            const bad = (e) => { cleanup(); reject(e); };
            const cleanup = () => { socket.off('connect', ok); socket.off('connect_error', bad); };
            socket.once('connect', ok);
            socket.once('connect_error', bad);
          });

          socket.on('connect', () => setStatus('Connected. Preparing device…'));
          socket.on('connect_error', (err) => setStatus(`Socket error: ${err.message}`, 'error'));
          socket.on('disconnect', (r) => setStatus(`Disconnected: ${r}`));

          // mediasoup pipeline
          await loadDevice();
          recvTransport = await createRecvTransport();
          videoConsumer = await consumeKind('video');
          audioConsumer = await consumeKind('audio');

          if (videoConsumer || audioConsumer) {
            setStatus(videoConsumer ? 'LIVE' : 'Audio only', 'live');
          } else {
            setStatus('Waiting for broadcaster…');
          }

          socket.on('newProducer', async ({ kind }) => {
            try {
              if (!device || !device.loaded || !recvTransport) return;
              const c = await consumeKind(kind);
              if (kind === 'video') { videoConsumer?.close(); videoConsumer = c; }
              else                  { audioConsumer?.close(); audioConsumer = c; }
              setStatus('LIVE', 'live');
            } catch (e) { console.warn('reconsume failed', e); }
          });

          // Report dimensions to Flutter (optional)
          await sleep(500);
          if (window.flutter_inappwebview?.callHandler) {
            window.flutter_inappwebview.callHandler('videoResolutionChanged', {
              width:  videoEl.videoWidth  || 0,
              height: videoEl.videoHeight || 0
            });
          }

          return { ok: true };
        } catch (e) {
          console.error(e);
          setStatus(e.message || 'init failed', 'error');
          return { ok: false, error: String(e) };
        }
      },
      async enterFullscreen() {
        if (videoEl.requestFullscreen) await videoEl.requestFullscreen().catch(()=>{});
        return { ok: true };
      },
      async exitFullscreen() {
        if (document.fullscreenElement) await document.exitFullscreen().catch(()=>{});
        return { ok: true };
      }
    };

    // -------- AUTO-START (fixes “Waiting for init…”) ----------
    (async function autoStart() {
      try {
        const qs = new URLSearchParams(location.search);
        const ident = qs.get('slug') || qs.get('liveId') || qs.get('id') || qs.get('room') || qs.get('ch') || '';
        if (!ident) {
          setStatus('Missing id/slug', 'error');
          return;
        }
        // If token is present in the URL, pass it. Otherwise playerBridge.init will still try with empty token.
        const token = qs.get('token') || '';
        // Use the same host the page was loaded from.
        const host = location.origin;

        // Small delay to ensure the module is fully set up on some devices
        await sleep(100);
        await window.playerBridge.init({ host, role: 'viewer', token, slug: ident, liveId: ident });
      } catch (e) {
        console.error('autoStart error', e);
        setStatus('Auto-start failed', 'error');
      }
    })();

    // report resize to Flutter (optional)
    const notifySize = () => {
      if (window.flutter_inappwebview?.callHandler) {
        window.flutter_inappwebview.callHandler('videoResolutionChanged', {
          width: videoEl.videoWidth, height: videoEl.videoHeight
        });
      }
    };
    videoEl.onloadedmetadata = notifySize;
    videoEl.onresize = notifySize;
  </script>
</body>
</html>
