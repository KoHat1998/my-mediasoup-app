<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>KoHat Live Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; width:100%; overflow:hidden; }
    video { width:100%; height:100%; object-fit:contain; background:#000; }
    #status {
      position:absolute; top:10px; left:10px; z-index:10;
      padding:4px 8px; border-radius:4px; color:#fff; font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:rgba(0,0,0,.7);
    }
  </style>
</head>
<body>
  <div style="position:relative;width:100%;height:100%;">
    <video id="remoteVideo" autoplay playsinline></video>
    <span id="status">Player ready. Waiting for init…</span>
  </div>

  <!-- Socket.IO served by your Node server -->
  <script src="/socket.io/socket.io.js"></script>

  <script type="module">
    import * as mediasoupClient from 'https://esm.sh/mediasoup-client@3';

    const statusEl = document.getElementById('status');
    const videoEl  = document.getElementById('remoteVideo');

    // ---------- helpers ----------
    function setStatus(msg, type='info') {
      statusEl.textContent = msg;
      statusEl.style.backgroundColor =
        type === 'live'  ? '#b00020' :
        type === 'error' ? '#6a1b1a' : 'rgba(0,0,0,.7)';
      // report to Flutter (optional)
      if (window.flutter_inappwebview?.callHandler) {
        window.flutter_inappwebview.callHandler('playerStatus', { message: msg, type }).catch(()=>{});
      }
      console.log('[PLAYER]', msg);
    }
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

    // ---------- mediasoup state ----------
    let socket;
    let device;
    let recvTransport;
    let videoConsumer = null, audioConsumer = null;
    const mediaStream = new MediaStream();
    videoEl.srcObject = mediaStream;

    function attachTrack(kind, track) {
      const old = kind==='video' ? mediaStream.getVideoTracks()[0] : mediaStream.getAudioTracks()[0];
      if (old) mediaStream.removeTrack(old);
      mediaStream.addTrack(track);
    }

    async function loadDevice() {
      const caps = await new Promise(res => socket.emit('getRtpCapabilities', res));
      device = new mediasoupClient.Device();
      await device.load({ routerRtpCapabilities: caps });
    }

    async function createRecvTransport() {
      const params = await new Promise(res => socket.emit('createRecvTransport', {}, res));
      if (params?.error) throw new Error(params.error);
      const t = device.createRecvTransport(params);
      t.on('connect', ({ dtlsParameters }, cb, eb) => {
        socket.emit('connectRecvTransport', { dtlsParameters }, (r) => {
          if (r === 'ok') cb(); else eb(new Error('connectRecvTransport failed'));
        });
      });
      return t;
    }

    async function consumeKind(kind) {
      const data = await new Promise(res => socket.emit('consume', { rtpCapabilities: device.rtpCapabilities, kind }, res));
      if (data?.error) {
        console.log(`No ${kind} yet:`, data.error);
        return null;
      }
      const c = await recvTransport.consume(data);
      attachTrack(kind, c.track);
      await new Promise(res => socket.emit('resume', { consumerId: c.id }, res));
      return c;
    }

    // ---------- bridge for Flutter (still available) ----------
    window.playerBridge = {
      /**
       * options: { host, token?, role='viewer', channelId?/slug?/liveId?/id?/room?/ch? }
       */
      async init(options) {
        try {
          if (!options?.host) throw new Error('host required');
          const channel = options.channelId || options.slug || options.liveId || options.id || options.room || options.ch;
          if (!channel) throw new Error('channelId/slug/liveId required');

          // The server middleware accepts raw or "Bearer <jwt>"
          const rawToken = options.token || new URL(location.href).searchParams.get('token') || '';
          const slug   = channel;
          const liveId = channel;

          setStatus('Connecting…');
          socket = io(options.host, {
            transports: ['websocket','polling'],
            auth: { role: options.role || 'viewer', token: rawToken, slug, liveId }
          });

          socket.on('connect', () => setStatus('Connected. Preparing device…'));
          socket.on('connect_error', (err) => setStatus(`Socket connection error: ${err.message}`, 'error'));
          socket.on('disconnect', (r) => setStatus(`Disconnected: ${r}`));

          // re-consume when a new producer appears
          socket.on('newProducer', async ({ kind }) => {
            try {
              if (!device || !device.loaded || !recvTransport) return;
              const c = await consumeKind(kind);
              if (kind === 'video') { videoConsumer?.close(); videoConsumer = c; }
              else                  { audioConsumer?.close(); audioConsumer = c; }
              setStatus('LIVE', 'live');
            } catch(e){ console.warn('reconsume failed', e); }
          });

          await new Promise((resolve, reject) => {
            if (socket.connected) return resolve();
            const ok = ()=>{ cleanup(); resolve(); };
            const bad=(e)=>{ cleanup(); reject(e); };
            const cleanup=()=>{ socket.off('connect', ok); socket.off('connect_error', bad); };
            socket.once('connect', ok);
            socket.once('connect_error', bad);
          });

          await loadDevice();
          recvTransport = await createRecvTransport();

          videoConsumer = await consumeKind('video');
          audioConsumer = await consumeKind('audio');

          if (videoConsumer || audioConsumer) {
            setStatus(videoConsumer ? 'LIVE' : 'Audio only', 'live');
          } else {
            setStatus('Waiting for broadcaster…');
          }

          // report initial size to Flutter
          await sleep(500);
          if (window.flutter_inappwebview?.callHandler) {
            window.flutter_inappwebview.callHandler('videoResolutionChanged', {
              width: videoEl.videoWidth  || 0,
              height: videoEl.videoHeight || 0
            }).catch(()=>{});
          }

          return { ok:true };
        } catch (e) {
          console.error(e);
          setStatus(e.message || 'init failed', 'error');
          return { ok:false, error:String(e) };
        }
      },
      async enterFullscreen(){ if (videoEl.requestFullscreen) await videoEl.requestFullscreen().catch(()=>{}); return {ok:true}; },
      async exitFullscreen(){ if (document.fullscreenElement) await document.exitFullscreen().catch(()=>{}); return {ok:true}; }
    };

    // ---------- autostart (works without Flutter calling init) ----------
    (function autoStartIfParamsPresent(){
      const qs = new URLSearchParams(location.search);
      const ident = qs.get('slug') || qs.get('liveId') || qs.get('id') || qs.get('room') || qs.get('ch');
      const host  = qs.get('host') || `${location.protocol}//${location.host}`;
      const autostart = qs.get('autostart');
      if (autostart === '1' || ident) {
        console.log('[AutoStart] host=', host, ' ident=', ident);
        setStatus('Autostarting…');
        window.playerBridge.init({
          host,
          token: qs.get('token') || '',
          role: 'viewer',
          slug: ident,
          liveId: ident
        });
      }
    })();

    // ---------- notify Flutter when size changes ----------
    videoEl.onloadedmetadata = () => {
      if (window.flutter_inappwebview?.callHandler) {
        window.flutter_inappwebview.callHandler('videoResolutionChanged', {
          width: videoEl.videoWidth, height: videoEl.videoHeight
        }).catch(()=>{});
      }
    };
    videoEl.onresize = videoEl.onloadedmetadata;
  </script>
</body>
</html>
