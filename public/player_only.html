<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>KoHat Live Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; padding: 0; background: black; height: 100%; width: 100%; overflow: hidden; }
    video { width: 100%; height: 100%; object-fit: contain; background: black; }
    #status-overlay { /* Changed from #live for more general status */
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.7);
      color: white;
      font-size: 14px;
      border-radius: 4px;
      font-family: sans-serif;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div style="position:relative;width:100%;height:100%;">
    <video id="remoteVideo" autoplay playsinline></video>
    <span id="status-overlay">Connecting…</span>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import * as mediasoupClient from 'https://esm.sh/mediasoup-client@3';

    const remoteVideoEl = document.getElementById('remoteVideo');
    const statusOverlayEl = document.getElementById('status-overlay');

    // --- Communication with Flutter ---
    function emitToFlutter(handlerName, data) {
      if (window.flutter_inappwebview && typeof window.flutter_inappwebview.callHandler === 'function') {
        window.flutter_inappwebview.callHandler(handlerName, data)
          .then(result => console.log(`Flutter handled ${handlerName}:`, result))
          .catch(err => console.error(`Error calling Flutter handler ${handlerName}:`, err));
      } else {
        console.log(`Flutter bridge not available. Event: ${handlerName}`, data);
      }
    }

    // --- Player Logic ---
    let socket; // Define socket globally in this script
    let device, recvTransport;
    const mediaStream = new MediaStream(); // Keep this if you still build the stream manually
    let videoConsumer = null, audioConsumer = null;
    let currentChannelId = null;
    let viewerCount = 0;

    function updateStatus(message, type = 'info') {
      statusOverlayEl.textContent = message;
      if (type === 'live') statusOverlayEl.style.backgroundColor = 'red';
      else if (type === 'error') statusOverlayEl.style.backgroundColor = 'darkred';
      else statusOverlayEl.style.backgroundColor = 'rgba(0,0,0,0.7)';
      emitToFlutter('playerStatus', { message, type });
    }

    function attachTrack(kind, track){
      // ... (same as your working version)
      if (kind === 'video') {
        const old = mediaStream.getVideoTracks()[0];
        if (old) mediaStream.removeTrack(old);
        mediaStream.addTrack(track);
      } else {
        const old = mediaStream.getAudioTracks()[0];
        if (old) mediaStream.removeTrack(old);
        mediaStream.addTrack(track);
      }
      if (!remoteVideoEl.srcObject) remoteVideoEl.srcObject = mediaStream;
       
      // Monitor resolution changes if it's a video track
      if (kind === 'video' && track) {
          // A short delay to ensure the track is active and settings are available
          setTimeout(() => {
              const settings = track.getSettings();
              if (settings.width && settings.height) {
                  emitToFlutter('videoResolutionChanged', { width: settings.width, height: settings.height });
              }
          }, 1000); // Adjust delay if needed
      }
    }

    async function loadDevice(){
      const caps = await new Promise(res => socket.emit('getRtpCapabilities', res));
      device = new mediasoupClient.Device();
      await device.load({ routerRtpCapabilities: caps });
      console.log("Mediasoup device loaded");
    }

    async function makeRecvTransport(channelIdForTransport) { // Pass channelId explicitly
      const params = await new Promise(res => socket.emit('createRecvTransport', { channelId: channelIdForTransport }, res));
      if (params?.error) throw new Error(`CreateRecvTransport Error: ${params.error}`);
      const t = device.createRecvTransport(params);
      t.on('connect', ({ dtlsParameters }, callback, errback) => {
        socket.emit('connectRecvTransport', { channelId: channelIdForTransport, dtlsParameters }, (r) => {
          if (r === 'ok') {
            console.log("RecvTransport connected");
            callback();
          } else {
            console.error("RecvTransport connection failed from server");
            errback(new Error('connectRecvTransport failed from server'));
          }
        });
      });
      // Listen for 'producerresume' and 'producerpause' on the transport if needed
      return t;
    }

    async function consumeKind(kind, channelIdToConsume) { // Pass channelId explicitly
      updateStatus(`Consuming ${kind}...`, 'info');
      const data = await new Promise(res => socket.emit('consume', { channelId: channelIdToConsume, rtpCapabilities: device.rtpCapabilities, kind }, res));
      if (data?.error) {
        console.warn(`Cannot consume ${kind}: ${data.error}`);
        if (kind === 'video') updateStatus('Waiting for broadcaster…', 'waiting');
        return null;
      }
      const consumer = await recvTransport.consume(data);
      console.log(`${kind} consumer created:`, consumer.id);
      attachTrack(kind, consumer.track);
      await new Promise(res => socket.emit('resume', { consumerId: consumer.id }, res));
      console.log(`${kind} consumer resumed:`, consumer.id);
      return consumer;
    }

    async function startWatch(channelId, host) {
      if (!channelId) {
        updateStatus('No channel selected', 'error');
        return;
      }
      if (socket && socket.connected && currentChannelId === channelId) {
        console.log("Already connected to this channel.");
        return;
      }
      if (socket && socket.connected && currentChannelId !== channelId) {
          // If connected to a different channel, disconnect first
          // This is a simplified disconnect; a full cleanup might be needed
          console.log(`Switching from ${currentChannelId} to ${channelId}`);
          socket.emit('leave', {channelId: currentChannelId }); // Assuming a 'leave' event
          if (recvTransport) {
              recvTransport.close();
              recvTransport = null;
          }
          if(videoConsumer) { videoConsumer.close(); videoConsumer = null; }
          if(audioConsumer) { audioConsumer.close(); audioConsumer = null; }
          // Potentially socket.disconnect() if the host might also change or for a cleaner switch
      }
      currentChannelId = channelId; // Set current channel

      try {
        updateStatus(`Connecting to ${channelId}...`, 'info');

        if (!socket || !socket.connected) {
            console.log(`Connecting Socket.IO to host: ${host}`);
            // Use the host provided by Flutter for Socket.IO connection
            socket = io(host, {
                transports: ['websocket', 'polling'],
                timeout: 10000, // 10 seconds
            });
            setupSocketListeners(); // Setup general listeners once
        }


        // Wait for socket to be connected if it was just created
        if (!socket.connected) {
            await new Promise((resolve, reject) => {
                socket.once('connect', resolve);
                socket.once('connect_error', (err) => reject(new Error(`Socket connection error: ${err.message}`)));
                // No need to call socket.connect() explicitly, io() does this.
            });
        }
        console.log("Socket.IO connected. ID:", socket.id);
        emitToFlutter('socketState', { connected: true, id: socket.id });


        updateStatus(`Joining ${channelId}...`, 'info');
        await new Promise(res => socket.emit('join', { channelId }, res)); // Use currentChannelId
        console.log("Joined channel:", currentChannelId);
        emitToFlutter('channelJoined', { channelId: currentChannelId });

        if (!device || !device.loaded) { // Ensure device is loaded
            await loadDevice();
        }
        
        recvTransport = await makeRecvTransport(currentChannelId);
        videoConsumer = await consumeKind('video', currentChannelId);
        audioConsumer = await consumeKind('audio', currentChannelId);

        if (videoConsumer) {
          updateStatus('LIVE', 'live');
          emitToFlutter('streamState', { live: true, hasVideo: true, hasAudio: !!audioConsumer });
        } else if (audioConsumer) {
          updateStatus('Audio Only', 'live');
          emitToFlutter('streamState', { live: true, hasVideo: false, hasAudio: true });
        } else {
          updateStatus(`Waiting for content on ${currentChannelId}...`, 'waiting');
          emitToFlutter('streamState', { live: false });
        }

      } catch (e) {
        console.error("Error during watch:", e);
        updateStatus(`Error: ${e.message || 'unknown'}`, 'error');
        emitToFlutter('playerError', { context: 'watch', message: e.message, stack: e.stack });
      }
    }
    
    function setupSocketListeners() {
        if (!socket) return;

        // Reconsume on new producer
        socket.on('newProducer', async ({ channelId: cid, kind }) => {
            if (cid !== currentChannelId || !device || !recvTransport || !device.loaded) {
                console.log("Skipping newProducer event: wrong channel, device not ready, or transport not ready.");
                return;
            }
            try {
                console.log(`New ${kind} producer detected for channel ${cid}. Reconsuming.`);
                // Close existing consumer for this kind if it exists
                if (kind === 'video' && videoConsumer) {
                    videoConsumer.close();
                    videoConsumer = null;
                } else if (kind === 'audio' && audioConsumer) {
                    audioConsumer.close();
                    audioConsumer = null;
                }

                const newConsumer = await consumeKind(kind, currentChannelId); // Use currentChannelId
                if (newConsumer) {
                    if (kind === 'video') videoConsumer = newConsumer;
                    else audioConsumer = newConsumer;
                    updateStatus('LIVE', 'live'); // Or more specific status
                    emitToFlutter('streamState', { live: true, hasVideo: !!videoConsumer, hasAudio: !!audioConsumer });
                }
            } catch (e) { console.error(`Error reconsuming ${kind}:`, e); }
        });

        socket.on('producerClosed', ({ channelId: cid, kind, producerId }) => {
            if (cid !== currentChannelId) return;
            console.log(`${kind} producer ${producerId} closed.`);
            if (kind === 'video' && videoConsumer && videoConsumer.producerId === producerId) {
                videoConsumer.close();
                videoConsumer = null;
                console.log("Video consumer closed.");
            } else if (kind === 'audio' && audioConsumer && audioConsumer.producerId === producerId) {
                audioConsumer.close();
                audioConsumer = null;
                console.log("Audio consumer closed.");
            }
            if (!videoConsumer && !audioConsumer) {
                updateStatus(`Stream ended on ${currentChannelId}. Waiting...`, 'waiting');
                emitToFlutter('streamState', { live: false });
            } else if (!videoConsumer && audioConsumer) {
                 updateStatus('Audio Only', 'live');
                 emitToFlutter('streamState', { live: true, hasVideo: false, hasAudio: true });
            }
            // else: video might still be there if only audio closed, or vice-versa
        });

        socket.on('viewerCount', ({ count }) => {
            viewerCount = count;
            console.log("Viewer count:", count);
            emitToFlutter('viewerCountChanged', { count });
        });
        
        socket.on('disconnect', (reason) => {
            console.log("Socket.IO disconnected. Reason:", reason);
            updateStatus(`Disconnected: ${reason}`, 'info');
            emitToFlutter('socketState', { connected: false, reason: reason });
            // Cleanup state
            if (recvTransport) { recvTransport.close(); recvTransport = null; }
            if (videoConsumer) { videoConsumer.close(); videoConsumer = null; }
            if (audioConsumer) { audioConsumer.close(); audioConsumer = null; }
            // Don't nullify device, it can be reused.
            // currentChannelId = null; // Or keep it if you intend to reconnect to the same
        });

        socket.on('connect_error', (err) => {
            console.error("Socket.IO connection error:", err);
            updateStatus(`Socket Error: ${err.message}`, 'error');
            emitToFlutter('socketState', { connected: false, error: err.message });
        });
    }


    // --- Functions callable from Flutter ---
    window.playerBridge = {
      init: (options) => {
        console.log("[PlayerBridge] init called by Flutter with:", options);
        if (!options || !options.channelId || !options.host) {
          const errMsg = "PlayerBridge.init requires 'channelId' and 'host'.";
          console.error(errMsg);
          updateStatus(errMsg, 'error');
          emitToFlutter('playerError', { context: 'init', message: errMsg });
          return Promise.reject(new Error(errMsg)); // Return a rejected promise
        }
        // Store config for potential reconnects if needed, though startWatch now takes host
        // window.playerConfig = options; 

        // Return a promise that resolves/rejects based on startWatch outcome
        return new Promise((resolve, reject) => {
            startWatch(options.channelId, options.host)
                .then(() => {
                    console.log("[PlayerBridge] startWatch completed successfully for init.");
                    resolve({ status: "Player initialized and attempting to stream." });
                })
                .catch(err => {
                    console.error("[PlayerBridge] startWatch failed during init:", err);
                    reject(err); // The error from startWatch will be passed up
                });
        });
      },
      disconnect: () => {
        console.log("[PlayerBridge] disconnect called by Flutter");
        if (socket && socket.connected) {
          socket.disconnect(); // This will trigger the 'disconnect' event listener for cleanup
        }
        // Explicitly clear some state, though 'disconnect' listener should also do it
        if (recvTransport) { recvTransport.close(); recvTransport = null; }
        if (videoConsumer) { videoConsumer.close(); videoConsumer = null; }
        if (audioConsumer) { audioConsumer.close(); audioConsumer = null; }
        currentChannelId = null;
        updateStatus('Disconnected by app', 'info');
        emitToFlutter('streamState', { live: false });
        return Promise.resolve({ status: "Disconnect initiated." });
      },
      enterFullscreen: () => {
        console.log("[PlayerBridge] enterFullscreen called by Flutter");
        if (remoteVideoEl.requestFullscreen) {
          remoteVideoEl.requestFullscreen().catch(err => console.error("Error entering fullscreen:", err));
        } else if (remoteVideoEl.webkitRequestFullscreen) { /* Safari */
          remoteVideoEl.webkitRequestFullscreen().catch(err => console.error("Error entering fullscreen (webkit):", err));
        } else if (remoteVideoEl.msRequestFullscreen) { /* IE11 */
          remoteVideoEl.msRequestFullscreen().catch(err => console.error("Error entering fullscreen (ms):", err));
        }
        return Promise.resolve({ status: "Fullscreen request sent." });
      },
      exitFullscreen: () => {
        console.log("[PlayerBridge] exitFullscreen called by Flutter");
        if (document.exitFullscreen) {
          document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err));
        } else if (document.webkitExitFullscreen) { /* Safari */
          document.webkitExitFullscreen().catch(err => console.error("Error exiting fullscreen (webkit):", err));
        } else if (document.msExitFullscreen) { /* IE11 */
          document.msExitFullscreen().catch(err => console.error("Error exiting fullscreen (ms):", err));
        }
        return Promise.resolve({ status: "Exit fullscreen request sent." });
      },
      getVideoResolution: () => {
        console.log("[PlayerBridge] getVideoResolution called by Flutter");
        if (videoConsumer && videoConsumer.track && videoConsumer.track.readyState === 'live') {
          const settings = videoConsumer.track.getSettings();
          if (settings.width && settings.height) {
            return Promise.resolve({ width: settings.width, height: settings.height });
          }
        }
        return Promise.resolve({ width: 0, height: 0, message: "Video track not available or no resolution data." });
      },
      // Example: Mute/Unmute (if you want to control from Flutter)
      // setMuted: (muted) => {
      //   console.log(`[PlayerBridge] setMuted called by Flutter: ${muted}`);
      //   remoteVideoEl.muted = muted;
      //   return Promise.resolve({ muted: remoteVideoEl.muted });
      // }
    };

    // --- Event Listeners for Video Element ---
    remoteVideoEl.onloadedmetadata = () => {
      console.log("Video metadata loaded. Dimensions:", remoteVideoEl.videoWidth, remoteVideoEl.videoHeight);
      emitToFlutter('videoResolutionChanged', { width: remoteVideoEl.videoWidth, height: remoteVideoEl.videoHeight });
    };

    remoteVideoEl.onresize = () => { // This event fires when the video's intrinsic size changes
      console.log("Video resized. Dimensions:", remoteVideoEl.videoWidth, remoteVideoEl.videoHeight);
      emitToFlutter('videoResolutionChanged', { width: remoteVideoEl.videoWidth, height: remoteVideoEl.videoHeight });
    };
    
    // Listen for browser fullscreen changes
    document.addEventListener('fullscreenchange', () => emitToFlutter('fullscreenChanged', { isFullscreen: !!document.fullscreenElement }));
    document.addEventListener('webkitfullscreenchange', () => emitToFlutter('fullscreenChanged', { isFullscreen: !!document.webkitFullscreenElement })); // Safari


    // Remove initial auto-watch if Flutter will call init
    // const initialChannelId = new URLSearchParams(location.search).get('ch');
    // const initialHost = new URLSearchParams(location.search).get('host') || location.origin; // Default to current origin if no host param
    // if (initialChannelId) {
    //   console.log(`Initial auto-watch for channel: ${initialChannelId} on host: ${initialHost}`);
    //   startWatch(initialChannelId, initialHost);
    // } else {
    //   updateStatus('Ready. Waiting for init.', 'info');
    // }
    updateStatus('Player Ready. Waiting for init from app.', 'info');


  </script>
</body>
</html>
