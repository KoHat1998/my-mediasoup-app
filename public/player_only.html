<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>KoHat Live Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    html, body { margin:0; padding:0; height:100%; width:100%; background:#000; }
    .wrap { display:flex; flex-direction:column; min-height:100vh; }
    header { padding:10px 14px; border-bottom:1px solid #00000022; display:flex; align-items:center; gap:10px; background:#0b0b0b; color:#fff; }
    header h1 { margin:0; font-size:16px; font-weight:600; }
    main { flex:1; display:flex; align-items:center; justify-content:center; padding:0; }
    video { width:100vw; height:calc(100vh - 88px); object-fit:contain; background:#000; }
    .row { display:flex; gap:8px; align-items:center; }
    .pill { padding:4px 8px; border-radius:999px; font-size:12px; background:#2563eb; color:white; }
    footer { padding:8px 14px; border-top:1px solid #00000022; display:flex; justify-content:space-between; align-items:center; font-size:12px; color:#ddd; background:#0b0b0b; }
    .muted { opacity:.8 }
    button { padding:8px 12px; border-radius:8px; border:1px solid #00000033; background:#111827; color:white; cursor:pointer; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row"><span class="pill" id="status">Idle</span></div>
    <h1 id="title">Viewer</h1>
    <div style="margin-left:auto" class="muted" id="info"></div>
  </header>
  <main>
    <video id="video" playsinline autoplay muted controls></video>
  </main>
  <footer>
    <div class="muted">Press play if your browser blocks autoplay.</div>
    <div><button id="unmute">Unmute</button></div>
  </footer>
</div>

<script src="/socket.io/socket.io.js"></script>

<!-- WebView safety shims (must run before mediasoup-client import) -->
<script>
(function () {
  function defaultCaps(kind){
    if (kind === 'audio') {
      return { codecs: [{ mimeType: 'audio/opus', clockRate: 48000, channels: 2 }], headerExtensions: [] };
    }
    return {
      codecs: [
        { mimeType: 'video/VP8',  clockRate: 90000 },
        { mimeType: 'video/H264', clockRate: 90000, parameters: { 'level-asymmetry-allowed': 1, 'packetization-mode': 1, 'profile-level-id': '42e01f' } }
      ],
      headerExtensions: []
    };
  }
  function wrapCaps(obj, fn) {
    try {
      const base = obj && obj[fn] && obj[fn].bind(obj);
      obj[fn] = function(kind){
        try {
          const v = base ? base(kind) : null;
          if (v && typeof v === 'object' && Array.isArray(v.codecs)) return v;
        } catch(e){}
        return defaultCaps(kind);
      };
    } catch (_) {}
  }
  if (!window.RTCRtpReceiver) window.RTCRtpReceiver = {};
  if (!window.RTCRtpSender)   window.RTCRtpSender   = {};
  wrapCaps(window.RTCRtpReceiver, 'getCapabilities');
  wrapCaps(window.RTCRtpSender,   'getCapabilities');

  if (window.MediaSource && typeof MediaSource.isTypeSupported === 'function') {
    try {
      const orig = MediaSource.isTypeSupported.bind(MediaSource);
      MediaSource.isTypeSupported = (t)=>{ try { return orig(t); } catch(_) { return false; } };
    } catch(_) {}
  }
})();
</script>

<script type="module">
  import * as mediasoupClientNS from 'https://esm.sh/mediasoup-client@3';
  const mediasoupClient = mediasoupClientNS?.default ?? mediasoupClientNS;

  const qs = new URLSearchParams(location.search);
  const ident = qs.get('slug') || qs.get('liveId') || qs.get('id') || qs.get('room') || qs.get('ch') || '';
  const token = qs.get('token') || ''; // raw or Bearer ...

  const $status = document.getElementById('status');
  const $title  = document.getElementById('title');
  const $info   = document.getElementById('info');
  const $video  = document.getElementById('video');
  const $unmute = document.getElementById('unmute');

  $title.textContent = 'Viewer: ' + (ident || '(no id)');
  $info.textContent  = location.host;

  function say(msg, type='info'){
    $status.textContent = msg;
    $status.style.background = type === 'error' ? '#ef4444' : '#2563eb';
    if (window.flutter_inappwebview?.callHandler) {
      window.flutter_inappwebview.callHandler('playerStatus', { message: msg, type });
    }
    console.log('[VIEWER]', msg);
  }

  if (!ident) {
    say('Missing id/slug', 'error');
    throw new Error('Provide ?slug= or ?liveId= or ?id= or ?room=');
  }

  try {
    if (token) {
      const bearer = /^Bearer\s+/i.test(token) ? token : ('Bearer ' + token);
      localStorage.setItem('token', bearer);
      localStorage.setItem('authToken', bearer.replace(/^Bearer\s+/i,''));
    }
  } catch(_) {}

  say('Connecting…');
  const socket = io('/', {
    path: '/socket.io',
    transports: ['websocket','polling'],
    withCredentials: true,
    auth: {
      role: 'viewer',
      token: token ? (/^Bearer\s+/i.test(token) ? token : 'Bearer ' + token) : undefined,
      slug: ident,
      liveId: ident
    }
  });

  socket.on('connect_error', (e) => { console.log('[VIEWER] connect_error', e?.message || e); say('Connect error', 'error'); });
  socket.on('disconnect',   (r) => { say('Disconnected: ' + r, 'error'); });

  // mediasoup pipeline (force handler Chrome74 so we skip WebView detection path)
  let device, recvTransport;

  async function emitAck(event, payload){
    return new Promise((resolve, reject) => {
      socket.timeout(10000).emit(event, payload, (res) => {
        if (res && res.error) return reject(new Error(res.error));
        resolve(res);
      });
    });
  }

  async function ensureDevice() {
    if (device) return;
    say('Loading caps…');
    const routerRtpCapabilities = await emitAck('getRtpCapabilities', null);
    device = new mediasoupClient.Device({ handlerName: 'Chrome74' });
    await device.load({ routerRtpCapabilities });
    console.log('[VIEWER] device loaded with handler Chrome74');
  }

  async function ensureRecvTransport() {
    if (recvTransport) return;
    say('Creating transport…');
    const tInfo = await emitAck('createRecvTransport', null);
    recvTransport = device.createRecvTransport(tInfo);
    recvTransport.on('connect', ({ dtlsParameters }, cb, err) => {
      emitAck('connectRecvTransport', { dtlsParameters }).then(cb).catch(err);
    });
  }

  async function consume(kind) {
    await ensureDevice();
    await ensureRecvTransport();

    const res = await emitAck('consume', { rtpCapabilities: device.rtpCapabilities, kind });
    if (res?.error) throw new Error(res.error);

    const consumer = await recvTransport.consume({
      id: res.id,
      producerId: res.producerId,
      kind: res.kind,
      rtpParameters: res.rtpParameters
    });

    const ms = $video.srcObject || new MediaStream();
    ms.addTrack(consumer.track);
    $video.srcObject = ms;

    await emitAck('resume', { consumerId: consumer.id });
    return consumer;
  }

  socket.on('connect', async () => {
    try {
      await consume('video').catch(()=>{});
      await consume('audio').catch(()=>{});
      say('LIVE');
    } catch (e) {
      console.warn('[VIEWER] fatal error', e);
      say('Error: ' + (e?.message || e), 'error');
      alert('Viewer error: ' + (e?.message || e));
    }
  });

  socket.on('newProducer', async (p) => {
    try {
      if (p.kind === 'video') await consume('video');
      if (p.kind === 'audio') await consume('audio');
      say('LIVE');
    } catch (e) {
      console.warn('[VIEWER] newProducer consume failed', e);
    }
  });

  $unmute.addEventListener('click', async () => {
    try { $video.muted = false; await $video.play().catch(()=>{}); } catch(_) {}
  });
</script>
</body>
</html>
