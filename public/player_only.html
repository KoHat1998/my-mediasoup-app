<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>KoHat Live Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; width:100%; overflow:hidden; }
    video { width:100%; height:100%; object-fit:contain; background:#000; }
    #status {
      position:absolute; top:10px; left:10px; z-index:10;
      padding:4px 8px; border-radius:4px; color:#fff; font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:rgba(0,0,0,.7);
    }
  </style>
</head>
<body>
  <div style="position:relative;width:100%;height:100%;">
    <video id="remoteVideo" autoplay playsinline></video>
    <span id="status">Player ready. Waiting for init…</span>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import * as mediasoupClient from 'https://esm.sh/mediasoup-client@3';

    const statusEl = document.getElementById('status');
    const videoEl  = document.getElementById('remoteVideo');

    // -------- small helpers ----------
    function setStatus(msg, type='info') {
      statusEl.textContent = msg;
      statusEl.style.backgroundColor =
        type === 'live'  ? '#b00020' :
        type === 'error' ? '#6a1b1a' : 'rgba(0,0,0,.7)';
      if (window.flutter_inappwebview?.callHandler) {
        window.flutter_inappwebview.callHandler('playerStatus', { message: msg, type });
      }
      console.log('[PLAYER]', msg);
    }
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

    // -------- mediasoup state ----------
    let socket;
    let device;
    let recvTransport;
    let videoConsumer, audioConsumer;
    const mediaStream = new MediaStream();
    videoEl.srcObject = mediaStream;

    function attachTrack(kind, track){
      const old = kind==='video' ? mediaStream.getVideoTracks()[0] : mediaStream.getAudioTracks()[0];
      if (old) mediaStream.removeTrack(old);
      mediaStream.addTrack(track);
    }

    async function loadDevice() {
      const caps = await new Promise(res => socket.emit('getRtpCapabilities', res));
      device = new mediasoupClient.Device();
      await device.load({ routerRtpCapabilities: caps });
    }

    async function createRecvTransport() {
      const params = await new Promise(res => socket.emit('createRecvTransport', {}, res));
      if (params?.error) throw new Error(params.error);
      const t = device.createRecvTransport(params);
      t.on('connect', ({ dtlsParameters }, cb, eb) => {
        socket.emit('connectRecvTransport', { dtlsParameters }, (r) => r==='ok' ? cb() : eb(new Error('connectRecvTransport failed')));
      });
      return t;
    }

    async function consumeKind(kind) {
      const data = await new Promise(res => socket.emit('consume', { rtpCapabilities: device.rtpCapabilities, kind }, res));
      if (data?.error) {
        console.log(`No ${kind} yet:`, data.error);
        return null;
      }
      const c = await recvTransport.consume(data);
      attachTrack(kind, c.track);
      await new Promise(res => socket.emit('resume', { consumerId: c.id }, res));
      return c;
    }

    // -------- public bridge for Flutter ----------
    window.playerBridge = {
      /**
       * options: { host, token?, role='viewer', channelId?, slug?, liveId? }
       * We will send {role, token, slug, liveId} in Socket.IO handshake (what your Node expects).
       */
      async init(options) {
        try {
          if (!options?.host) throw new Error('host required');
          // Accept id under multiple keys; your Node accepts either slug or liveId
          const channel = options.channelId || options.slug || options.liveId || options.id || options.room || options.ch;
          if (!channel) throw new Error('channelId/slug/liveId required');

          // Normalize auth for handshake (Node middleware will add "Bearer" prefix if missing)
          const rawToken = options.token || (new URL(location.href)).searchParams.get('token') || '';
          const slug     = channel;   // treat the same value as slug
          const liveId   = channel;   // and as liveId (server will match either)

          // Create socket with handshake auth — THIS is the key change
          setStatus('Connecting…');
          socket = io(options.host, {
            transports: ['websocket','polling'],
            auth: {
              role: options.role || 'viewer',
              token: rawToken,  // can be raw "eyJ…" or "Bearer eyJ…" — server normalizes
              slug,
              liveId
            }
          });

          // connection lifecycle
          socket.on('connect', () => setStatus('Connected. Preparing device…'));
          socket.on('connect_error', (err) => setStatus(`Socket connection error: ${err.message}`, 'error'));
          socket.on('disconnect', (r) => setStatus(`Disconnected: ${r}`));

          // broadcaster appears later? re-consume on demand
          socket.on('newProducer', async ({ kind, slug: s }) => {
            // your server sends {kind, slug}; we don’t filter by slug here
            try {
              if (!device || !device.loaded || !recvTransport) return;
              const c = await consumeKind(kind);
              if (kind === 'video') { videoConsumer?.close(); videoConsumer = c; }
              else                  { audioConsumer?.close(); audioConsumer = c; }
              setStatus('LIVE', 'live');
            } catch (e) { console.error('reconsume failed', e); }
          });

          // wait until socket connected
          await new Promise((resolve, reject) => {
            if (socket.connected) return resolve();
            const onOk = () => { cleanup(); resolve(); };
            const onBad = (e) => { cleanup(); reject(e); };
            const cleanup = () => {
              socket.off('connect', onOk);
              socket.off('connect_error', onBad);
            };
            socket.once('connect', onOk);
            socket.once('connect_error', onBad);
          });

          // mediasoup pipeline
          await loadDevice();
          recvTransport = await createRecvTransport();

          videoConsumer = await consumeKind('video');
          audioConsumer = await consumeKind('audio');

          if (videoConsumer || audioConsumer) {
            setStatus(videoConsumer ? 'LIVE' : 'Audio only', 'live');
          } else {
            setStatus('Waiting for broadcaster…');
          }

          // Some devices only expose dimensions later
          await sleep(500);
          if (window.flutter_inappwebview?.callHandler) {
            window.flutter_inappwebview.callHandler('videoResolutionChanged', {
              width:  videoEl.videoWidth  || 0,
              height: videoEl.videoHeight || 0
            });
          }

          return { ok: true };
        } catch (e) {
          console.error(e);
          setStatus(e.message || 'init failed', 'error');
          return { ok: false, error: String(e) };
        }
      },
      async enterFullscreen() {
        if (videoEl.requestFullscreen) await videoEl.requestFullscreen().catch(()=>{});
        return { ok: true };
      },
      async exitFullscreen() {
        if (document.fullscreenElement) await document.exitFullscreen().catch(()=>{});
        return { ok: true };
      }
    };

    // report resize to Flutter (optional)
    videoEl.onloadedmetadata = () => {
      if (window.flutter_inappwebview?.callHandler) {
        window.flutter_inappwebview.callHandler('videoResolutionChanged', {
          width: videoEl.videoWidth, height: videoEl.videoHeight
        });
      }
    };
    videoEl.onresize = videoEl.onloadedmetadata;
  </script>
</body>
</html>
