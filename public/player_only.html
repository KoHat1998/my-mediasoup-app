<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>KoHat Live Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; width:100%; overflow:hidden; }
    video { width:100%; height:100%; object-fit:contain; background:#000; }
    #status {
      position:absolute; top:10px; left:10px; z-index:10;
      padding:4px 8px; border-radius:4px; color:#fff; font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:rgba(0,0,0,.7);
    }
  </style>
</head>
<body>
  <div style="position:relative;width:100%;height:100%;">
    <video id="remoteVideo" autoplay playsinline></video>
    <span id="status">Player ready. Waiting for init…</span>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import * as mediasoupClient from 'https://esm.sh/mediasoup-client@3';

    const statusEl = document.getElementById('status');
    const videoEl  = document.getElementById('remoteVideo');

    function setStatus(msg, type='info') {
      statusEl.textContent = msg;
      statusEl.style.backgroundColor =
        type === 'live'  ? '#b00020' :
        type === 'error' ? '#6a1b1a' : 'rgba(0,0,0,.7)';
      window.flutter_inappwebview?.callHandler?.('playerStatus', { message: msg, type });
      console.log('[PLAYER]', msg);
    }

    // mediasoup state
    let socket;
    let device;
    let recvTransport;
    let videoConsumer = null, audioConsumer = null;
    const mediaStream = new MediaStream();
    videoEl.srcObject = mediaStream;

    function attachTrack(kind, track){
      const old = kind==='video' ? mediaStream.getVideoTracks()[0] : mediaStream.getAudioTracks()[0];
      if (old) mediaStream.removeTrack(old);
      mediaStream.addTrack(track);
    }

    // ---- Ack helper (critical fix) ----
    function emitAck(event, payload) {
      return new Promise((resolve, reject) => {
        socket.timeout(8000).emit(event, payload ?? null, (res) => {
          if (res && res.error) return reject(new Error(res.error));
          resolve(res);
        });
      });
    }

    async function loadDevice(){
      const caps = await emitAck('getRtpCapabilities', null);
      device = new mediasoupClient.Device();
      await device.load({ routerRtpCapabilities: caps });
    }

    async function createRecvTransport(){
      const params = await emitAck('createRecvTransport', null);
      const t = device.createRecvTransport(params);
      t.on('connect', ({ dtlsParameters }, cb, eb) => {
        emitAck('connectRecvTransport', { dtlsParameters }).then(()=>cb()).catch(eb);
      });
      return t;
    }

    async function consumeKind(kind){
      const data = await emitAck('consume', { rtpCapabilities: device.rtpCapabilities, kind });
      if (!data) return null; // server returned nothing (shouldn’t happen)
      if (data.error) {
        console.log(`No ${kind} yet:`, data.error);
        return null;
      }
      const c = await recvTransport.consume(data);
      attachTrack(kind, c.track);
      await emitAck('resume', { consumerId: c.id });
      return c;
    }

    // -------- public bridge for Flutter ----------
    window.playerBridge = {
      async init(options) {
        try {
          if (!options?.host) throw new Error('host required');
          const channel = options.channelId || options.slug || options.liveId || options.id || options.room || options.ch;
          if (!channel) throw new Error('channelId/slug/liveId required');

          const rawToken = options.token || (new URL(location.href)).searchParams.get('token') || '';
          const slug   = channel;
          const liveId = channel;

          setStatus('Connecting…');
          socket = io(options.host, {
            transports: ['websocket','polling'],
            auth: {
              role: options.role || 'viewer',
              token: rawToken,    // raw "eyJ…" or "Bearer …"; server normalizes
              slug,
              liveId
            }
          });

          socket.on('connect', () => setStatus('Connected. Preparing device…'));
          socket.on('connect_error', (err) => setStatus(`Socket connection error: ${err.message}`, 'error'));
          socket.on('disconnect', (r) => setStatus(`Disconnected: ${r}`));

          socket.on('newProducer', async ({ kind }) => {
            try {
              if (!device || !device.loaded || !recvTransport) return;
              const c = await consumeKind(kind);
              if (kind === 'video') { videoConsumer?.close(); videoConsumer = c; }
              else                  { audioConsumer?.close(); audioConsumer = c; }
              setStatus('LIVE', 'live');
            } catch (e) { console.error('reconsume failed', e); }
          });

          // wait for connected
          await new Promise((resolve, reject) => {
            if (socket.connected) return resolve();
            const ok = () => { cleanup(); resolve(); };
            const bad = (e) => { cleanup(); reject(e); };
            const cleanup = () => { socket.off('connect', ok); socket.off('connect_error', bad); };
            socket.once('connect', ok);
            socket.once('connect_error', bad);
          });

          await loadDevice();
          recvTransport = await createRecvTransport();

          videoConsumer = await consumeKind('video');
          audioConsumer = await consumeKind('audio');

          if (videoConsumer || audioConsumer) {
            setStatus(videoConsumer ? 'LIVE' : 'Audio only', 'live');
          } else {
            setStatus('Waiting for broadcaster…');
          }

          // report initial size once available
          setTimeout(() => {
            window.flutter_inappwebview?.callHandler?.('videoResolutionChanged', {
              width:  videoEl.videoWidth  || 0,
              height: videoEl.videoHeight || 0
            });
          }, 500);

          return { ok: true };
        } catch (e) {
          console.error(e);
          setStatus(e.message || 'init failed', 'error');
          return { ok: false, error: String(e) };
        }
      },
      async enterFullscreen() {
        if (videoEl.requestFullscreen) await videoEl.requestFullscreen().catch(()=>{});
        return { ok: true };
      },
      async exitFullscreen() {
        if (document.fullscreenElement) await document.exitFullscreen().catch(()=>{});
        return { ok: true };
      }
    };

    // report size changes to Flutter
    videoEl.onloadedmetadata = videoEl.onresize = () => {
      window.flutter_inappwebview?.callHandler?.('videoResolutionChanged', {
        width: videoEl.videoWidth, height: videoEl.videoHeight
      });
    };
  </script>
</body>
</html>
